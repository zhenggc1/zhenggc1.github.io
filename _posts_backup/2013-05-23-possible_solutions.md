---
layout: post
title: "可能的方案"
description: ""
category: 
tags: [模拟方法]
---
{% include JB/setup %}

# 代理模式

既然是需要对外围调用做模拟，首先想到是从网络层想办法，一个可能的方案就是对jvm加代理

    System.setProperty("socksProxyHost", sockshost);
    System.setProperty("socksProxyPort", sockport);

或者启动的时候添加-D参数，这样，所有外围的交互都会通过这个sock代理，那控制这个代理，也就控制了所有的网路请求，包含请求结果。

但是这种情况下，你需要了解所有外围应用的协议，简单的如http，并且是公开的，有些比较复杂，比如mysql的交互协议，也是公开的，虽然复杂点，还是有希望处理的。但是如oracle的协议，有些企业内部定制的协议，根本就无法了解，当然这种情况还可以让企业内部人员写插件作为扩展，oracle的协议应该也被猜的差不多了。终极问题，加密协议，比如https，暂无解。


# 方法字节码处理

另外一个方式，就是在java内部处理，通过字节码修改和外围通讯的方法，检查调用参数，根据参数返回不同的结果。

这种情况下，实际的外围是有状态的，比如一个简单的例子，从数据库中获取某个记录，修改某个字段，然后再持久化到数据库中，再获取这个记录，第一次获取和第二次获取，应该是返回不同的内容，单如果你只是以参数来判断不同的结果，获得的是相同的结果。

简单的说，想用一个无状态的外围来模拟一个有状态的外围，就是一个悲剧。毕竟一个谎言说出来之后，需要更多的谎言来弥补前面的谎言带来的问题。


你需要重新设定一个世界。


